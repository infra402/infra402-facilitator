# x402 Facilitator Configuration Example
#
# This file shows all available configuration options for the x402 facilitator.
# Copy this file to `config.toml` and customize as needed.
#
# Configuration file location can be specified via CONFIG_FILE environment variable:
#   CONFIG_FILE=/path/to/config.toml infra402-facilitator
#
# Default location: ./config.toml (in current directory)

# ================================
# Rate Limiting Configuration
# ================================
[rate_limiting]
# Enable or disable rate limiting globally
enabled = true

# Global rate limit (requests per second per IP address)
# This applies to all endpoints unless overridden
requests_per_second = 50

# Duration in seconds to ban an IP after threshold violations
# Default: 300 seconds (5 minutes)
ban_duration_seconds = 600

# Number of rate limit violations before triggering a temporary ban
# Default: 5 violations
ban_threshold = 5

# Per-endpoint rate limit overrides (optional)
# Specify custom limits for specific endpoints
[rate_limiting.endpoints]
# Example: Limit /verify endpoint to 5 requests/second
verify = 25
# Example: Limit /settle endpoint to 2 requests/second
settle = 25
# Note: endpoint names should match route paths without leading slash

# ================================
# CORS Configuration
# ================================
[cors]
# List of allowed origins for CORS requests
# Empty list = allow all origins (*)
# Specify exact origins for production:
allowed_origins = [
    # "https://example.com",
    # "https://app.example.com",
]

# ================================
# IP Filtering Configuration
# ================================
[ip_filtering]
# List of allowed IP addresses or CIDR blocks
# Empty list = allow all IPs
# If specified, ONLY these IPs/ranges will be allowed
allowed_ips = [
    # "192.168.1.0/24",
    # "10.0.0.1",
]

# List of blocked IP addresses or CIDR blocks
# IPs on this list will be rejected regardless of allow list
blocked_ips = [
    # "192.0.2.0/24",
    # "198.51.100.50",
]

# ================================
# Request Configuration
# ================================
[request]
# Maximum request body size in bytes
# Default: 1048576 (1 MB)
# Prevents abuse via large payloads
max_body_size_bytes = 1048576

# ================================
# Security Configuration
# ================================
[security]
# Require API key authentication for /health endpoint
# Default: false (public access)
health_endpoint_requires_auth = false

# Enable logging of security-related events
# Includes: rate limit violations, auth failures, blocked IPs, etc.
# Default: true
log_security_events = true

# Cleanup interval for abuse detector and rate limiter (in seconds)
# This controls how often old tracking data is purged from memory
# Default: 300 seconds (5 minutes)
cleanup_interval_seconds = 3600

# ================================
# Transaction Configuration
# ================================
[transaction]
# Default RPC request timeout in seconds
# This is used as a fallback when chain-specific configuration is not provided
# Default: 30 seconds
default_rpc_timeout_seconds = 30

# Chain-specific configurations
# Format: [transaction.chains.<network-name>]
# Network name should match the chain ID mapping in src/chain/evm.rs

# BSC (BNB Smart Chain) - Chain ID 56
[transaction.chains.bsc]
block_time_seconds = 3
receipt_timeout_blocks = 20  # 60 seconds total (20 blocks * 3s)
rpc_request_timeout_seconds = 15  # BSC RPCs can be slow/flaky

# BSC Testnet - Chain ID 97
[transaction.chains.bsc-testnet]
block_time_seconds = 3
receipt_timeout_blocks = 20  # 60 seconds total
rpc_request_timeout_seconds = 15

# Base - Chain ID 8453
[transaction.chains.base]
block_time_seconds = 2
receipt_timeout_blocks = 30  # 60 seconds total (30 blocks * 2s)
rpc_request_timeout_seconds = 20

# Ethereum Mainnet - Chain ID 1
[transaction.chains.ethereum]
block_time_seconds = 12
receipt_timeout_blocks = 10  # 120 seconds total (10 blocks * 12s)
rpc_request_timeout_seconds = 30

# Polygon - Chain ID 137
[transaction.chains.polygon]
block_time_seconds = 2
receipt_timeout_blocks = 30  # 60 seconds total
rpc_request_timeout_seconds = 20

# Avalanche C-Chain - Chain ID 43114
[transaction.chains.avalanche]
block_time_seconds = 2
receipt_timeout_blocks = 30  # 60 seconds total
rpc_request_timeout_seconds = 20

# ================================
# Batch Settlement Configuration
# ================================
# Enable Multicall3 batching to bundle multiple settlements into single transactions
# for improved throughput (up to 100-150x) and reduced gas costs (~75% savings)
#
# Supports per-network configuration overrides to tune batching parameters independently
# for each blockchain network (e.g., different batch sizes for Base vs BSC)
[batch_settlement]
# Enable batching globally (default: false for backward compatibility)
enabled = false

# Global default: Maximum settlements per batch (default: 150)
# Theoretical max ~545 based on gas limit, but 150 is safer
max_batch_size = 150

# Global default: Maximum milliseconds to wait before flushing batch (default: 500)
# Lower = better latency, higher = better batching efficiency
max_wait_ms = 500

# Global default: Minimum batch size for immediate flush (default: 10)
# If queue reaches this size, flush immediately without waiting
min_batch_size = 100

# Global default: Allow individual transfers to fail without reverting entire batch (default: false)
# false = strict (any failure reverts all), true = permissive (continue on failures)
allow_partial_failure = false

# Per-network configuration overrides (optional)
# Only specified fields override global defaults for each network
# Network names: base, base-sepolia, bsc, bsc-testnet, avalanche, avalanche-fuji,
#                polygon, polygon-amoy, sei, sei-testnet, xdc, solana, solana-devnet

# Example: BSC with larger batches and longer wait time
# [batch_settlement.networks.bsc]
# max_batch_size = 200
# max_wait_ms = 1000
# allow_partial_failure = true

[batch_settlement.networks.bsc-testnet]
max_batch_size = 100
max_wait_ms = 1000
allow_partial_failure = false

# Example: Base with smaller batches and faster flush for lower latency
# [batch_settlement.networks.base]
# max_batch_size = 50
# max_wait_ms = 250
# min_batch_size = 5

# Example: Avalanche with aggressive batching for high throughput
# [batch_settlement.networks.avalanche]
# max_batch_size = 300
# max_wait_ms = 2000
# allow_partial_failure = true
